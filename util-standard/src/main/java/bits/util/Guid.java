/* 
 * Copyright (c) 2012, Massachusetts Institute of Technology
 * Released under the BSD 2-Clause License
 * http://opensource.org/licenses/BSD-2-Clause 
 */ 
package bits.util;

import java.net.*;
import java.security.*;

import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.util.*;

import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;


/**
 * Guid class that conforms to RFC-4122, Variant 4 (Leach-Salz), Versions 1, 3, and 4.
 * This implementation is intentionally similar to {@link java.util.UUID}.
 * However, this implementation is more complete and far more memory efficient.
 * <p>
 * The RFC-4122 specification uses the term "UUID". I use "Guid" here because it is
 * easier to say, and because it conforms to Java's own naming standard for 
 * initialisms ( unlike java.util.UUID ). RFC-4122 describes several "versions" of
 * Guids generated by different processes. This class can generate three versions:
 * <i>time-based</i>, <i>name-based using MD5 hash</i>, and <i>random</i>.
 * The default is <i>time-based</i>.
 * <p>
 * Each Guid contains 128 bits, stored internally as two <tt>long</tt> values. 
 * RFC-4122 is meant to be backwards compatible with a whole lot of other UUID
 * specs, so the layout is more confusing than you might expect. All Guids generated
 * by this class will contain a valid version and variant field:  
 * 
 * <pre>
 * Most Significant Bits 
 * version : 0x000000000000F000
 * Least Significant Bits
 * variant : 0xC000000000000000
 * </pre>
 * 
 * The <i>version</i> field specifies the type of Guid:
 * <pre>
 * 0x1 : Time-based
 * 0x2 : DCE Security, with embedded POSIX UUID (not generated by this class)
 * 0x3 : Name-based using MD5 hash
 * 0x4 : Random-generated
 * 0x5 : Name-based using SHA-1 hash (not generated by this class)
 * </pre>
 *
 * The <i>reserved</i> field is the variant. All Guids generated by 
 * this class have <code>reserved = 0x2</code>.
 * 
 * @author Philip DeCamp
 * @deprecated Use Uuids instead. java.util.UUID is now somewhat sane.
 */
public final class Guid implements Serializable, Comparable<Guid> {

    private static final long serialVersionUID = -3271834344024722331L;
    
    /**
     * The time difference between the JVM epoch: 01 Jan 1970 00:00:00 UTC and
     * the RFC-4122 GUID epoch: 15 Oct 1582 00:00:00 UTC
     * 
     * Note that this number is negative.
     */
    private static final long   OFFSET_MILLIS     = 0xFFFFF4E2F964AC00L;
    private static final char[] TABLE_TO_BASE64   = new char[64];
    private static final int[]  TABLE_FROM_BASE64 = new int[128];
    private static final char[] TABLE_TO_URL      = new char[64];
    private static final int[]  TABLE_FROM_URL    = new int[128];

    private static final SecureRandom sSecureRand = new SecureRandom();
    private static final long sStaticBits;
    private static final byte[] sWork = new byte[16];
    
    private static MessageDigest sDigest = null;
    private static long sLastTimestamp = Long.MIN_VALUE;
    
    
    static {
        // Initialize Base64 conversion tables.
        // Table was found to be faster in unit tests compared to if-thens or switches.
        // While this may be partially due to these tables staying in cache,
        // the branching version of the code was probably not much smaller than
        // these tables anyway.
        for( int i = 0; i < 26; i++ ) {
            TABLE_TO_BASE64[i] = (char)( 'A' + i );
        }
        for( int i = 26; i < 52; i++ ) {
            TABLE_TO_BASE64[i] = (char)( 'a' + ( i - 26 ) );
        }
        for( int i = 52; i < 62; i++ ) {
            TABLE_TO_BASE64[i] = (char)( '0' + ( i - 52 ) );
        }
        TABLE_TO_BASE64[62] = '+';
        TABLE_TO_BASE64[63] = '/';

        System.arraycopy( TABLE_TO_BASE64, 0, TABLE_TO_URL, 0, TABLE_TO_BASE64.length );
        TABLE_TO_URL[62] = '_';
        TABLE_TO_URL[63] = '-';

        Arrays.fill( TABLE_FROM_BASE64, -1 );
        Arrays.fill( TABLE_FROM_URL, -1 );
        for( int i = 0; i < 64; i++ ) {
            TABLE_FROM_BASE64[ TABLE_TO_BASE64[i] ] = i;
            TABLE_FROM_URL[ TABLE_TO_URL[i] ] = i;
        }

        // Initialize statically random bits.

        // Get clock sequence bits.
        long clockSequence;
        Preferences pref = Preferences.userNodeForPackage( Guid.class );
        
        try {
            pref.sync();
            clockSequence = ( pref.getInt( "clock_sequence", sSecureRand.nextInt() ) + 1 ) & 0x3FFF;
            pref.putInt( "clock_sequence", (int)clockSequence );
            pref.flush();
        } catch( BackingStoreException ex ) {
            clockSequence = sSecureRand.nextInt() & 0x3FFF;
        }
        
        clockSequence = clockSequence << 48;
        
        // Get random bits.
        long rand = sSecureRand.nextLong() & 0x0000FFFF00000000L;
        
        // Get node bits.
        MessageDigest digest;
        
        try {
            digest = MessageDigest.getInstance( "MD5" );
        } catch( NoSuchAlgorithmException ex ) {
            throw new ExceptionInInitializerError( ex );
        }

        try {
            try {
                InetAddress addr = InetAddress.getLocalHost();
                if( addr != null ) {
                    NetworkInterface net = NetworkInterface.getByInetAddress( addr );
                    if( net != null ) {
                        digest.update( net.getHardwareAddress() );
                    } else {
                        digest.update( addr.toString().getBytes( "UTF-8" ) );
                    }
                }
            } catch( UnknownHostException ignore ) {
            } catch( SocketException ignore ) {}
            
            digest.update( (byte)'#' );
            String s = System.getProperty( "user.name" );
            if( s != null ) {
                digest.update( s.getBytes( "UTF-8" ) );
            }
        } catch( UnsupportedEncodingException exc ) {
            throw new ExceptionInInitializerError( exc );
        }
        
        byte[] arr = digest.digest();
        long node = 0;
        
        for( int i = 0; i < arr.length; i++ ) {
            long shift = (i % 4) * 8;
            node ^= ( (long)( arr[i] & 0xFF ) << shift );
        }
        
        // Combine bits into static portion of guid.
        sStaticBits = ( 0x8000000000000000L |
                        clockSequence |
                        rand |
                        node );
    }

    
    /**
     * Equivalent to createTimeBased(), which is considered the default version. 
     */
    public static Guid create() {
        return createTimeBased();
    }

    /**
     * Returns a new time-based Guid. This implementation has been modified lightly
     * from the original RFC-4122 spec in that the node field has been
     * reduced from 48 bits to 32 bits in order to add a 16-bit random field.
     * The returned Guid will contain:
     * 
     * <pre>
     * Most Significant Bits 
     * time_low     : 0xFFFFFFFF00000000
     * time_mid     : 0x00000000FFFF0000
     * version      : 0x000000000000F000
     * time_hi      : 0x0000000000000FFF
     * 
     * Least Significant Bits
     * reserved     : 0xC000000000000000
     * clk_seq      : 0x3FFF000000000000
     * random       : 0x0000FFFF00000000
     * node         : 0x00000000FFFFFFFF
     * </pre>
     * <p>
     * time_low:time_low - 60 timestamp bits. This number represents the number of 
     * 100-nanosecond  intervals that have occurred since 15 Oct 1582, 00:00:00 UTC. 
     * Note that the Java clock is used, which is only accurate to within about 20ms. 
     * However, this method guarantees that each timestamp will be at least 100ns 
     * greater than the previously generated timestamp. This means that if Guids are 
     * generated at a sustained rate greater than 10,000,000 per second, the timestamps 
     * may become very inaccurate.
     * <p>
     * clk_seq - 14 clock sequence bits. The clock sequence is randomly initialized and
     * stored for each user using the java.util.Preferences API. The clock
     * sequence is incremented after retrieval, so the same user may use this
     * class in multiple JVMs at the same time without collision. As
     * the Preferences API does not contain a global locking method, there is a
     * very remote chance that two applications that access this class at the
     * same time may retrieve the same clock sequence.
     * <p>
     * random - 16 random bits. These are generated at class initialization using a
     * secure random number generator. This is meant to reduce collisions in
     * cases where a given user is generating guids from multiple applications
     * on the same machine.
     * <p>
     * node - 32 node bits. These bits contain an MD5 hash of the MAC address of the
     * user's ethernet card along with the user's login name.
     * <p>
     * reserved - 2 variant bits, set to b10.
     * <p>
     * version - 4 version bits, set to b0001.
     * 
     * @return new time-based guid.
     */
    public static synchronized Guid createTimeBased() {
        long timestamp = ( System.currentTimeMillis() + OFFSET_MILLIS ) * 10000L;
        if( timestamp <= sLastTimestamp ) {
            timestamp = ++sLastTimestamp;
        } else {
            sLastTimestamp = timestamp;
        }

        long timeBits = 0x0000000000001000;
        timeBits |= ( (timestamp << 32) & 0xFFFFFFFF00000000L );
        timeBits |= ( (timestamp >> 16) & 0x00000000FFFF0000L );
        timeBits |= ( (timestamp >> 48) & 0x0000000000000FFFL );

        return new Guid( timeBits, sStaticBits );
    }
    
    /**
     * Returns a new random guid (version 0x4). The returned Guid will contain:
     * 
     * <pre>
     * Most Significant Bits 
     * random0      : 0xFFFFFFFFFFFF0000
     * version      : 0x000000000000F000
     * random1      : 0x0000000000000FFF
     * 
     * Least Significant Bits
     * reserved     : 0xC000000000000000
     * random2      : 0x3FFFFFFFFFFFFFFF
     * </pre>
     * 
     * <p>
     * random0:random1:random2 - 122 random bits generated from a secure pseudo-random number generator.
     * <p>
     * reserved - 2 variant bits, set to b10.
     * <p>
     * version - 4 version bits, set to b0100.
     * 
     * @return a new random Guid.
     */
    public static synchronized Guid createRandom() {
        byte[] b = sWork;
        sSecureRand.nextBytes( b );
        b[6] &= 0x0F;
        b[6] |= 0x40;
        b[8] &= 0x3F;
        b[8] |= 0x80;
        return Guid.fromBytes( b, 0 );
    }

    /**
     * Returns a new name-based guid using MD5 hash (version 0x3). This 
     * Guid is determined entirely by provided input, and different machines at
     * different times may create the same name-based guid by providing
     * the same namespace and name. The returned Guid will contain:
     * 
     * <pre>
     * Most Significant Bits 
     * hash0        : 0xFFFFFFFFFFFF0000
     * version      : 0x000000000000F000
     * hash1        : 0x0000000000000FFF
     * 
     * Least Significant Bits
     * reserved     : 0xC000000000000000
     * hash2        : 0x3FFFFFFFFFFFFFFF
     * </pre>
     * 
     * hash0:hash1:hash2 - 122 name hash bits. The hash bits are generated 
     * by feeding the 16 bytes provided by the namespace guid into an MD5 digest, 
     * followed by the UTF-8 bytes of the provided name.
     * <p>
     * reserved - 2 variant bits, set to b10.
     * <p>
     * version - 4 version bits, set to b0011.
     * 
     * @param namespace  The namespace being used. May be <code>null</code>.
     * @param name       The name.
     * @return a new name-based Guid.
     */
    public static synchronized Guid fromName( Guid namespace, String name ) {
        MessageDigest md;
        try {
            md = sDigest;
            if( md == null ) {
                md = sDigest = MessageDigest.getInstance( "MD5" );
                if( md.getDigestLength() < 16 ) {
                    throw new Exception( "Insufficient digest length" );
                }
            }
        } catch( Exception ex ) {
            throw new UnsupportedOperationException( "Suitable MD5 digest provider not found." );
        }
        
        md.reset();
        byte[] bytes;
        
        try {
            if( namespace != null ) {
                byte[] work = sWork;
                namespace.toBytes( work, 0 );
                md.update( work );
            }
            
            bytes = md.digest( name.getBytes( "UTF-8" ) );
        } catch( UnsupportedEncodingException ex ) {
            throw new UnsupportedOperationException( "UTF-8 encoding not available, amazingly enough." );
        }

        bytes[6] &= 0x0F;
        bytes[6] |= 0x30;
        bytes[8] &= 0x3F;
        bytes[8] |= 0x80;

        return Guid.fromBytes( bytes, 0 );
    }
    
    /**
     * @return Guid object equivalent to {@code uuid}.
     */
    public static Guid fromUUID( UUID uuid ) {
        return new Guid( uuid.getMostSignificantBits(), uuid.getLeastSignificantBits() );
    }

    /**
     * @param s  Guid data in canonical Base64 format
     * @return equivalent Guid object
     * @throws IllegalArgumentException if <code>s</code> is not a valid Base64 representation.
     */
    public static Guid fromBase64( String s ) {
        if( s.length() != 24 ) {
            throw new IllegalArgumentException( "Invalid Guid string: " + s );
        }
        
        //char[] c = s.toCharArray();
        long msb = 0;
        long lsb = 0;

        try {
            for( int i = 0; i < 10; i++ ) {
                int v = TABLE_FROM_BASE64[ s.charAt( i ) ];
                if( v < 0 ) {
                    throw new IllegalArgumentException( "Invalid Guid string: " + s );
                }
                msb <<= 6;
                msb |= v;
            }

            {
                lsb = TABLE_FROM_BASE64[ s.charAt( 10 ) ];
                if( lsb < 0 ) {
                    throw new IllegalArgumentException( "Invalid Guid string: " + s );
                }
                msb <<= 4;
                msb |= (lsb >> 2);
            }

            for( int i = 11; i < 21; i++ ) {
                int v = TABLE_FROM_BASE64[ s.charAt( i ) ];
                if( v < 0 ) {
                    throw new IllegalArgumentException( "Invalid Guid string: " + s );
                }
                lsb <<= 6;
                lsb |= v;
            }
            
            {
                int v = TABLE_FROM_BASE64[ s.charAt( 21 ) ];
                if( v < 0 ) {
                    throw new IllegalArgumentException( "Invalid Guid string: " + s );
                }
                lsb <<= 2;
                lsb |= ( v >> 4 );
            }
            
            if( s.charAt( 22 ) != '=' || s.charAt( 23 ) != '=' ) {
                throw new IllegalArgumentException( "Invalid Guid string: " + s );
            }
            
        } catch( Exception ex ) {
            if( ex instanceof IllegalArgumentException ) {
                throw (IllegalArgumentException)ex;
            } else {
                throw new IllegalArgumentException( "Invalid Guid string: " + s );
            }
        }

        return new Guid( msb, lsb );
    }

    /**
     * @param s UUID data in url-safe Base64 format
     * @return equivalent Guid object
     * @throws IllegalArgumentException if <code>s</code> is not a valid URL-Base64 representation.
     */
    public static Guid fromUrl( String s ) {
        if( s.length() != 22 ) {
            throw new IllegalArgumentException( "Invalid UUID string: " + s );
        }

        //char[] c = s.toCharArray();
        long msb = 0;
        long lsb = 0;

        try {
            for( int i = 0; i < 10; i++ ) {
                int v = TABLE_FROM_URL[ s.charAt( i ) ];
                if( v < 0 ) {
                    throw new IllegalArgumentException( "Invalid UUID string: " + s );
                }
                msb <<= 6;
                msb |= v;
            }

            {
                lsb = TABLE_FROM_URL[ s.charAt( 10 ) ];
                if( lsb < 0 ) {
                    throw new IllegalArgumentException( "Invalid UUID string: " + s );
                }
                msb <<= 4;
                msb |= (lsb >> 2);
            }

            for( int i = 11; i < 21; i++ ) {
                int v = TABLE_FROM_URL[ s.charAt( i ) ];
                if( v < 0 ) {
                    throw new IllegalArgumentException( "Invalid UUID string: " + s );
                }
                lsb <<= 6;
                lsb |= v;
            }

            {
                int v = TABLE_FROM_URL[ s.charAt( 21 ) ];
                if( v < 0 ) {
                    throw new IllegalArgumentException( "Invalid UUID string: " + s );
                }
                lsb <<= 2;
                lsb |= ( v >> 4 );
            }
        } catch( Exception ex ) {
            if( ex instanceof IllegalArgumentException ) {
                throw (IllegalArgumentException)ex;
            } else {
                throw new IllegalArgumentException( "Invalid UUID string: " + s );
            }
        }

        return new Guid( msb, lsb );
    }

    /**
     * @param s  Guid data in canonical hex format : "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"
     * @return parsed Guid object
     * @throws NumberFormatException if <code>s</code> cannot be parsed.
     */
    public static Guid fromHex( String s ) {
        if( s.length() != 36 ||
            s.charAt(  8 ) != '-' ||
            s.charAt( 13 ) != '-' ||
            s.charAt( 18 ) != '-' ||
            s.charAt( 23 ) != '-' )
        {
            throw new IllegalArgumentException();
        }
        
        long msb = 0;
        long lsb = 0;
        
        for( int i = 0; i < 8; i++ ) {
            msb = msb << 4 | parseHexChar( s.charAt( i ) );
        }
        for( int i = 9; i < 13; i++ ) {
            msb = msb << 4 | parseHexChar( s.charAt( i ) );
        }
        for( int i = 14; i < 18; i++ ) {
            msb = msb << 4 | parseHexChar( s.charAt( i ) );
        }
        for( int i = 19; i < 23; i++ ) {
            lsb = lsb << 4 | parseHexChar( s.charAt( i ) );
        }
        for( int i = 24; i < 36; i++ ) {
            lsb = lsb << 4 | parseHexChar( s.charAt( i ) );
        }
        
        return new Guid( msb, lsb );
    }
    
    /**
     * @param bytes Guid data in array of at least 16 bytes.
     * @param off Offset into <code>bytes</code> array.
     * @return Guid using first 16 bytes provide.
     */
    public static Guid fromBytes( byte[] bytes, int off ) {
        long msb = ( bytes[off + 0] & 0xFFL ) << 56 |
                   ( bytes[off + 1] & 0xFFL ) << 48 |
                   ( bytes[off + 2] & 0xFFL ) << 40 |
                   ( bytes[off + 3] & 0xFFL ) << 32 |
                   ( bytes[off + 4] & 0xFFL ) << 24 |
                   ( bytes[off + 5] & 0xFFL ) << 16 |
                   ( bytes[off + 6] & 0xFFL ) <<  8 |
                   ( bytes[off + 7] & 0xFFL );
            
        long lsb = ( bytes[off +  8] & 0xFFL ) << 56 |
                   ( bytes[off +  9] & 0xFFL ) << 48 |
                   ( bytes[off + 10] & 0xFFL ) << 40 |
                   ( bytes[off + 11] & 0xFFL ) << 32 |
                   ( bytes[off + 12] & 0xFFL ) << 24 |
                   ( bytes[off + 13] & 0xFFL ) << 16 |
                   ( bytes[off + 14] & 0xFFL ) <<  8 |
                   ( bytes[off + 15] & 0xFFL );
        
        return new Guid( msb, lsb );
    }


    final long mMostSig;
    final long mLeastSig;


    public Guid( long mostSigBits, long leastSigBits ) {
        mMostSig = mostSigBits;
        mLeastSig = leastSigBits;
    }


    public long mostSignificantBits() {
        return mMostSig;
    }

    public long leastSignificantBits() {
        return mLeastSig;
    }


    public int variant() {
        if( (mLeastSig >>> 62) == 0x2 ) {
            return 2;
        }
        if( (mLeastSig & 0x8000000000000000L) == 0 ) {
            return 0;
        }
        return (int)(mLeastSig >>> 61);
    }

    public int version() {
        return (int)(mMostSig >> 12) & 0x000F;
    }

    public boolean hasTimestamp() {
        return version() == 1;
    }

    public long timestampMicros() {
        long raw = rawTimestamp();
        return (raw / 10) - OFFSET_MILLIS * 1000;
    }

    public long rawTimestamp() {
        long t = ((mMostSig << 48) & 0x0FFF000000000000L);
        t |= ((mMostSig << 16) & 0x0000FFFF00000000L);
        t |= ((mMostSig >> 32) & 0x00000000FFFFFFFFL);

        return t;
    }

    public boolean hasClockSequence() {
        return version() == 1;
    }

    public int clockSequence() {
        return ((int)(mLeastSig >> 48) & 0x3FFF);
    }

    public boolean hasNode() {
        return version() == 1;
    }

    public long node() {
        return mLeastSig & 0x00000000FFFFFFFFL;
    }


    public UUID toUUID() {
        return new UUID( mMostSig, mLeastSig );
    }

    public String toHex() {
        // About 50x faster than using String.format().
        char[] c = new char[36];
        for( int i = 0; i < 8; i++ ) {
            c[i] = formatHexChar( (int)(mMostSig >> (60 - i * 4)) & 0xF );
        }
        c[8] = '-';
        for( int i = 9; i < 13; i++ ) {
            c[i] = formatHexChar( (int)(mMostSig >> (64 - i * 4)) & 0xF );
        }
        c[13] = '-';
        for( int i = 14; i < 18; i++ ) {
            c[i] = formatHexChar( (int)(mMostSig >> (68 - i * 4)) & 0xF );
        }
        c[18] = '-';
        for( int i = 19; i < 23; i++ ) {
            c[i] = formatHexChar( (int)(mLeastSig >> (136 - i * 4)) & 0xF );
        }
        c[23] = '-';
        for( int i = 24; i < 36; i++ ) {
            c[i] = formatHexChar( (int)(mLeastSig >> (140 - i * 4)) & 0xF );
        }

        return new String( c );
    }

    public String toBase64() {
        char[] c = new char[24];
        int shift = 58;

        for( int i = 0; i < 10; i++, shift -= 6 ) {
            c[i] = TABLE_TO_BASE64[(int)((mMostSig >> shift) & 0x3F)];
        }

        c[10] = TABLE_TO_BASE64[(int)((mMostSig << 2) & 0x3C | ((mLeastSig >>> 62) & 0x3))];

        shift = 56;
        for( int i = 11; i < 21; i++, shift -= 6 ) {
            c[i] = TABLE_TO_BASE64[(int)((mLeastSig >> shift) & 0x3F)];
        }

        c[21] = TABLE_TO_BASE64[(int)((mLeastSig << 4) & 0x30)];
        c[22] = '=';
        c[23] = '=';

        return new String( c );
    }

    public String toUrl() {
        char[] c = new char[22];
        int shift = 58;

        for( int i = 0; i < 10; i++, shift -= 6 ) {
            c[i] = TABLE_TO_URL[(int)((mMostSig >> shift) & 0x3F)];
        }

        c[10] = TABLE_TO_URL[(int)((mMostSig << 2) & 0x3C | ((mLeastSig >>> 62) & 0x3))];

        shift = 56;
        for( int i = 11; i < 21; i++, shift -= 6 ) {
            c[i] = TABLE_TO_URL[(int)((mLeastSig >> shift) & 0x3F)];
        }

        c[21] = TABLE_TO_URL[(int)((mLeastSig << 4) & 0x30)];

        return new String( c );
    }

    public byte[] toBytes() {
        byte[] ret = new byte[16];
        toBytes( ret, 0 );
        return ret;
    }

    public void toBytes( byte[] arr, int off ) {
        for( int i = 0; i < 8; i++ ) {
            arr[off + i] = (byte)(mMostSig >> 56 - i * 8);
        }
        off += 8;
        for( int i = 0; i < 8; i++ ) {
            arr[off + i] = (byte)(mLeastSig >> 56 - i * 8);
        }
    }

    public String toString() {
        return toHex();
    }

    public int hashCode() {
        return (int)((mMostSig >> 32) ^
                     (mMostSig) ^
                     (mLeastSig >> 32) ^
                     (mLeastSig));
    }

    public boolean equals( Object obj ) {
        if( !(obj instanceof Guid) ) {
            return false;
        }
        Guid g = (Guid)obj;
        return (mMostSig == g.mMostSig) &&
               (mLeastSig == g.mLeastSig);
    }

    public int compareTo( Guid val ) {
        if( mMostSig < val.mMostSig ) {
            return -1;
        }
        if( mMostSig > val.mMostSig ) {
            return 1;
        }
        if( mLeastSig < val.mLeastSig ) {
            return -1;
        }
        if( mLeastSig > val.mLeastSig ) {
            return 1;
        }
        return 0;
    }

    private static int parseHexChar( char c ) {
        if( c <= '9' ) {
            if( c >= '0' ) {
                return c - '0';
            }
        } else if( c <= 'F' ) {
            if( c >= 'A' ) {
                return c - ('A' - 10);
            }
        } else if( c <= 'f' ) {
            if( c >= 'a' ) {
                return c - ('a' - 10);
            }
        }

        throw new IllegalArgumentException();
    }

    private static char formatHexChar( int c ) {
        return (char)(c + (c < 10 ? '0' : 'A' - 10));
    }


    @Deprecated
    public static Guid fromString( String s ) {
        return fromHex( s );
    }

    @Deprecated
    public static Guid newCustomTimeInstance() {
        return createTimeBased();
    }

    @Deprecated
    public static synchronized Guid newNameInstance( Guid namespace, String name ) {
        return fromName( namespace, name );
    }

    @Deprecated
    public static Guid fromHexString( String s ) {
        return fromHex( s );
    }

    @Deprecated
    public static Guid fromBase64String( String s ) {
        return fromBase64( s );
    }

    @Deprecated
    public String toHexString() {
        return toHex();
    }

    @Deprecated
    public String toBase64String() {
        return toBase64();
    }

}
